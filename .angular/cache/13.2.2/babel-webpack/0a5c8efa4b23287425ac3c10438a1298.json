{"ast":null,"code":"import { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler) {\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return source => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexport class ExpandOperator {\n  constructor(project, concurrent, scheduler) {\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n  }\n\n  call(subscriber, source) {\n    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n  }\n\n}\nexport class ExpandSubscriber extends SimpleOuterSubscriber {\n  constructor(destination, project, concurrent, scheduler) {\n    super(destination);\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n    this.index = 0;\n    this.active = 0;\n    this.hasCompleted = false;\n\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      this.buffer = [];\n    }\n  }\n\n  static dispatch(arg) {\n    const {\n      subscriber,\n      result,\n      value,\n      index\n    } = arg;\n    subscriber.subscribeToProjection(result, value, index);\n  }\n\n  _next(value) {\n    const destination = this.destination;\n\n    if (destination.closed) {\n      this._complete();\n\n      return;\n    }\n\n    const index = this.index++;\n\n    if (this.active < this.concurrent) {\n      destination.next(value);\n\n      try {\n        const {\n          project\n        } = this;\n        const result = project(value, index);\n\n        if (!this.scheduler) {\n          this.subscribeToProjection(result, value, index);\n        } else {\n          const state = {\n            subscriber: this,\n            result,\n            value,\n            index\n          };\n          const destination = this.destination;\n          destination.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n        }\n      } catch (e) {\n        destination.error(e);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  subscribeToProjection(result, value, index) {\n    this.active++;\n    const destination = this.destination;\n    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));\n  }\n\n  _complete() {\n    this.hasCompleted = true;\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue) {\n    this._next(innerValue);\n  }\n\n  notifyComplete() {\n    const buffer = this.buffer;\n    this.active--;\n\n    if (buffer && buffer.length > 0) {\n      this._next(buffer.shift());\n    }\n\n    if (this.hasCompleted && this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n} //# sourceMappingURL=expand.js.map","map":null,"metadata":{},"sourceType":"module"}